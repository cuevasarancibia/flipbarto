<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Moto Zorro Veloz - ¡Aventura Súper Fácil!</title>
    <style>
        body {
            margin: 0;
            overflow: hidden; /* Evita scrollbars si el canvas es más grande que la ventana */
            background-color: #70c5ce; /* Cielo azul estilo Flappy Bird */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh; /* Ocupa toda la altura de la ventana */
            font-family: 'Arial', sans-serif; /* Fuente genérica por si falla la carga de otras */
        }
        #gameContainer {
            position: relative; /* Necesario para posicionar elementos absolutos internos */
            width: 320px; /* Ancho típico de Flappy Bird */
            height: 480px; /* Alto típico */
            border: 2px solid #000; /* Borde para delimitar el área de juego */
            overflow: hidden; /* Asegura que nada se salga del contenedor del juego */
            box-shadow: 0 0 10px rgba(0,0,0,0.5); /* Sombra para darle profundidad */
        }
        canvas {
            display: block; /* Evita espacios extra debajo del canvas */
            background-color: transparent; /* El fondo lo maneja el div o el dibujo en canvas */
        }
        #scoreDisplay {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%); /* Centra el score horizontalmente */
            font-size: 30px;
            font-weight: bold;
            color: white;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000; /* Contorno para legibilidad */
            z-index: 10; /* Asegura que esté sobre el canvas */
        }
        #messageDisplay {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%); /* Centra el mensaje */
            font-size: 24px;
            font-weight: bold;
            color: white;
            text-align: center;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
            z-index: 10;
            display: none; /* Oculto inicialmente */
            padding: 15px;
            background-color: rgba(0,0,0,0.4); /* Fondo semitransparente */
            border-radius: 8px;
            width: 80%; /* Para que no sea demasiado ancho */
            box-sizing: border-box; /* Para que el padding no aumente el ancho */
        }
        #pauseButton {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background-color: rgba(0,0,0,0.6);
            border: 2px solid white;
            border-radius: 5px;
            cursor: pointer;
            z-index: 11; /* Encima del score y mensajes */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .pauseIconBar {
            width: 5px;
            height: 20px;
            background-color: white;
            margin: 0 2px; /* Espacio entre las barras */
        }
        .playIconTriangle {
            width: 0;
            height: 0;
            border-top: 10px solid transparent; /* Crea un triángulo con bordes */
            border-bottom: 10px solid transparent;
            border-left: 18px solid white;
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="scoreDisplay">0</div>
        <div id="messageDisplay"></div>
        <div id="pauseButton">
            </div>
    </div>

    <script>
        // --- Elementos del DOM ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('gameContainer'); // Aunque no se usa directamente en JS, es bueno tener la referencia
        const scoreDisplay = document.getElementById('scoreDisplay');
        const messageDisplay = document.getElementById('messageDisplay');
        const pauseButton = document.getElementById('pauseButton');

        // --- Configuración del Canvas ---
        // Es mejor establecer el tamaño del canvas aquí en lugar de CSS para evitar distorsiones
        canvas.width = 320;
        canvas.height = 480;

        // --- ASSETS (Imágenes) ---
        // Se recomienda tener una carpeta 'assets' o 'img' en la raíz del proyecto de GitHub Pages
        // y luego referenciarla así: 'assets/motozorro.png' o './imagenes/motozorro.png'
        // Si la carpeta 'imagenes' está al mismo nivel que tu archivo HTML, './imagenes/' es correcto.

        const motoFoxImg = new Image();
        motoFoxImg.src = './imagenes/motozorro.png'; // Asegúrate que esta ruta sea correcta en GitHub

        const pipeTopImg = new Image();
        pipeTopImg.src = './imagenes/tuberia_arriba.svg'; // Los SVG son geniales para escalar

        const pipeBottomImg = new Image();
        pipeBottomImg.src = './imagenes/tuberia_abajo.svg';

        const groundImg = new Image();
        groundImg.src = './imagenes/suelo.svg';

        const bgImg = new Image();
        bgImg.src = './imagenes/fondo_juego.svg';

        const zorroVictoriaImg = new Image();
        zorroVictoriaImg.src = './imagenes/zorro_victoria.jpg';

        const dancingFoxImg = new Image(); // GIF del zorro bailando (Base64 para evitar problemas de ruta)
        dancingFoxImg.src = 'data:image/gif;base64,R0lGODlhIAAgAPIEAAAAAP/OAAAA/84A////AAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJFAACACwAAAAAIAAgAAADXei63P4wykmrvTjrzbv/YCiOZGmeaKqubOu+cCzPdG3feK7vfO//wKBwSCwaj8ikcslsOp/QqHRKrVqv2Kx2y+16v+CweEwum8/otHrNbrvf8Lh8Tq/b7/i8fs/v+/+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChooqMhR0AAAAh+QQJFAACACwEAAIAFwAWAAADQHi63P4wykmrvTjrzbv/YCiOZGmeaKqubOu+cCzPdG3feK7vfO//wKAwSBQeiEghlHMpyfE0pFQrjVLjB+xOq3f0mJxbM9oVAAA7';


        // --- Variables del Juego ---
        let motoX, motoY, motoVelocity, motoSize; // Propiedades del jugador (moto-zorro)
        let gravity; // Fuerza de gravedad
        let pipes; // Array para almacenar las tuberías
        let pipeWidth, pipeGap, pipeSpeed; // Propiedades de las tuberías
        let score; // Puntuación del jugador
        let frames; // Contador de frames (útil para temporizar eventos)
        let gameState; // Estado actual del juego ('READY', 'PLAYING', 'GAMEOVER', etc.)
        let isPaused = false; // Indicador de si el juego está pausado
        let groundHeight = 50; // Altura del suelo
        let groundX = 0; // Posición X del suelo (para efecto de scroll)

        const scoreMetaInicial = 10; // Puntuación para la victoria intermedia
        let victoriaAlcanzada = false; // Flag para controlar si ya se mostró la pantalla de victoria intermedia

        // --- Inicialización del Juego ---
        function init() {
            motoSize = 40; // Tamaño del zorro en la moto
            motoX = 60; // Posición X inicial
            motoY = canvas.height / 2 - motoSize / 2; // Posición Y inicial (centrado verticalmente)
            motoVelocity = 0; // Velocidad vertical inicial
            gravity = 0.05; // Gravedad MUY BAJA para modo fácil

            pipes = []; // Reinicia el array de tuberías
            pipeWidth = 64; // Ancho de las tuberías
            pipeGap = 220; // Espacio MUY GRANDE entre tuberías para modo fácil
            pipeSpeed = 0.8; // Velocidad MUY LENTA de las tuberías para modo fácil

            score = 0; // Reinicia la puntuación
            frames = 0; // Reinicia el contador de frames
            gameState = 'READY'; // Estado inicial del juego
            isPaused = false; // El juego no está pausado al inicio
            victoriaAlcanzada = false; // Reinicia el flag de victoria
            updatePauseButtonIcon(); // Actualiza el ícono del botón de pausa

            scoreDisplay.textContent = score; // Muestra la puntuación inicial
            messageDisplay.innerHTML = 'Pulsa o haz clic<br>para Empezar la Aventura'; // Mensaje inicial
            messageDisplay.style.display = 'block'; // Muestra el mensaje
            messageDisplay.style.top = '40%'; // Posición del mensaje
        }

        // --- Funciones de Dibujo ---
        function drawMoto() {
            ctx.save(); // Guarda el estado actual del contexto (transformaciones, estilos)
            ctx.translate(motoX + motoSize / 2, motoY + motoSize / 2); // Mueve el origen al centro de la moto para rotar
            
            // Calcula el ángulo de rotación basado en la velocidad vertical (efecto visual)
            let angle = Math.min(Math.PI / 8, motoVelocity * 0.08); // Limita la inclinación
            ctx.rotate(angle);

            // Dibuja la imagen del moto-zorro si está cargada, sino un rectángulo naranja
            if (motoFoxImg.complete && motoFoxImg.naturalWidth !== 0) {
                ctx.drawImage(motoFoxImg, -motoSize / 2, -motoSize / 2, motoSize, motoSize);
            } else {
                // Fallback si la imagen no carga
                ctx.fillStyle = 'orange';
                ctx.fillRect(-motoSize / 2, -motoSize / 2, motoSize, motoSize);
            }
            ctx.restore(); // Restaura el estado previo del contexto
        }

        function drawPipes() {
            pipes.forEach(pipe => {
                // Dibuja la tubería superior si la imagen está cargada
                if (pipeTopImg.complete && pipeTopImg.naturalWidth !== 0) {
                    ctx.drawImage(pipeTopImg, pipe.x, 0, pipeWidth, pipe.topHeight);
                } else {
                    // Fallback si la imagen no carga
                    ctx.fillStyle = 'green';
                    ctx.fillRect(pipe.x, 0, pipeWidth, pipe.topHeight);
                }
                // Dibuja la tubería inferior si la imagen está cargada
                if (pipeBottomImg.complete && pipeBottomImg.naturalWidth !== 0) {
                    ctx.drawImage(pipeBottomImg, pipe.x, pipe.topHeight + pipeGap, pipeWidth, canvas.height - pipe.topHeight - pipeGap - groundHeight);
                } else {
                    // Fallback si la imagen no carga
                    ctx.fillStyle = 'green';
                    ctx.fillRect(pipe.x, pipe.topHeight + pipeGap, pipeWidth, canvas.height - pipe.topHeight - pipeGap - groundHeight);
                }
            });
        }

        function drawGround() {
            // Dibuja el suelo repetidamente para crear efecto de scroll infinito
            if (groundImg.complete && groundImg.naturalWidth !== 0 && groundImg.width > 0) {
                 for (let i = 0; (i * groundImg.width) + groundX < canvas.width + groundImg.width; i++) {
                    ctx.drawImage(groundImg, (i * groundImg.width) + groundX, canvas.height - groundHeight, groundImg.width, groundHeight);
                }
            } else {
                // Fallback si la imagen no carga
                ctx.fillStyle = '#d2b48c'; // Color tierra
                ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            }
        }

        function drawBackground() {
            // Dibuja el fondo repetidamente para crear efecto de scroll infinito (parallax)
            if (bgImg.complete && bgImg.naturalWidth !== 0 && bgImg.width > 0) {
                 for (let i = 0; (i * bgImg.width) + (groundX * 0.5) < canvas.width + bgImg.width; i++) { // groundX * 0.5 para efecto parallax
                    let bgX = (i * bgImg.width) + (groundX * 0.5);
                    // Reposiciona el fondo si se sale completamente a la izquierda
                    while (bgX <= -bgImg.width && bgImg.width > 0) {
                        bgX += bgImg.width;
                    }
                    ctx.drawImage(bgImg, bgX , 0, bgImg.width, canvas.height - groundHeight);
                }
            } else {
                // Fallback si la imagen no carga (el body ya tiene un color de fondo)
                // Podrías dibujar un gradiente o algo simple aquí si quieres
            }
        }

        // --- Funciones de Actualización (Lógica del Juego) ---
        function updateMoto() {
            motoVelocity += gravity; // Aplica gravedad
            motoY += motoVelocity; // Mueve la moto verticalmente

            // Evita que la moto suba demasiado (con un pequeño margen)
            if (motoY < -motoSize * 0.2) {
                motoY = -motoSize * 0.2;
                motoVelocity = gravity * 2; // Empieza a caer suavemente
            }

            // Colisión con el suelo (solo previene que se hunda, gameOver lo maneja la colisión con tuberías o el suelo en `checkCollisions`)
            if (motoY + motoSize > canvas.height - groundHeight) {
                motoY = canvas.height - groundHeight - motoSize;
                // Si quieres que tocar el suelo sea game over, llama a gameOver() aquí
                // Por ahora, se maneja en checkCollisions para consistencia
            }
        }

        function updatePipes() {
            // Añade nuevas tuberías cada cierto número de frames (controla la frecuencia)
            if (frames % 200 === 0) { // Tuberías MUY POCO frecuentes para modo fácil
                let minTopHeight = 80; // Altura mínima de la tubería superior
                let maxTopHeightPossible = canvas.height - groundHeight - pipeGap - 80; // Deja espacio para tubería inferior

                let topHeight = Math.random() * (maxTopHeightPossible - minTopHeight) + minTopHeight;

                pipes.push({ x: canvas.width, topHeight: topHeight, passed: false });
            }

            pipes.forEach(pipe => {
                pipe.x -= pipeSpeed; // Mueve las tuberías hacia la izquierda

                // Elimina las tuberías que ya salieron de la pantalla
                if (pipe.x + pipeWidth < 0) {
                    pipes.shift(); // Quita el primer elemento del array (el más antiguo)
                }

                // Incrementa el score si la moto pasa una tubería
                if (!pipe.passed && pipe.x + pipeWidth < motoX) {
                    pipe.passed = true;
                    score++;
                    scoreDisplay.textContent = score;

                    // Comprueba si se alcanzó la meta para la victoria intermedia
                    if (score === scoreMetaInicial && !victoriaAlcanzada) {
                        mostrarPantallaVictoriaIntermedia();
                    } else if (score === 9999 && gameState !== 'ENDING') { // Límite de puntuación para el final
                        enterEndingSequence();
                    }
                }
            });
        }
        
        function checkCollisions() {
            if (gameState !== 'PLAYING') return; // Solo chequear colisiones si se está jugando

            // Colisión con el suelo
            if (motoY + motoSize > canvas.height - groundHeight) {
                motoY = canvas.height - groundHeight - motoSize; // Asegura que no se hunda
                gameOver();
                return; // Termina la función si hay colisión con el suelo
            }

            // Colisión con las tuberías
            for (let pipe of pipes) {
                const colisionMargen = 2; // Pequeño margen para no ser tan estricto
                if (motoX + motoSize - colisionMargen > pipe.x &&        // El lado derecho de la moto supera el lado izq de la tubería
                    motoX + colisionMargen < pipe.x + pipeWidth &&       // El lado izq de la moto está antes del lado der de la tubería
                    (motoY + colisionMargen < pipe.topHeight ||          // La parte superior de la moto toca la tubería de arriba
                     motoY + motoSize - colisionMargen > pipe.topHeight + pipeGap)) { // La parte inferior de la moto toca la tubería de abajo
                    gameOver();
                    return; // Termina la función si hay colisión con una tubería
                }
            }
        }


        function updateGround() {
            groundX -= pipeSpeed; // Mueve el suelo a la misma velocidad que las tuberías
            // Reposiciona el suelo para el efecto de scroll infinito
            if (groundImg.complete && groundImg.naturalWidth !== 0 && groundImg.width > 0) {
                if (groundX <= -groundImg.width) {
                    groundX += groundImg.width;
                }
            } else if (groundImg.width === 0 && groundImg.complete) { // Si la imagen cargó pero no tiene ancho (ej. SVG vacío)
                 // No hacer nada o usar un groundX = 0; para evitar bucles infinitos si se usa groundImg.width en la condición del bucle
            }
        }

        // --- Acciones del Jugador ---
        function flap() {
            if (gameState === 'PLAYING' && !isPaused) { // Solo permite saltar si está jugando y no pausado
                motoVelocity = -2.8; // Salto MUY SUAVE para modo fácil
            }
        }

        // --- Estados del Juego ---
        function gameOver() {
            // Evita múltiples llamadas a gameOver o si ya está en una secuencia final/victoria
            if (gameState === 'GAMEOVER' || gameState === 'ENDING' || gameState === 'VICTORY_INTERMEDIATE') return;
            
            gameState = 'GAMEOVER';
            messageDisplay.innerHTML = `¡Oh no, Zorro!<br>Puntuación: ${score}<br><small>Pulsa para reintentar</small>`;
            messageDisplay.style.top = '40%'; // Ajusta la posición si es necesario
            messageDisplay.style.display = 'block';
            // Aquí podrías añadir un sonido de "game over"
        }

        function mostrarPantallaVictoriaIntermedia() {
            if (gameState === 'ENDING') return; // No mostrar si ya está en la secuencia final

            isPaused = true; // Pausa el juego lógicamente
            victoriaAlcanzada = true;
            gameState = 'VICTORY_INTERMEDIATE';
            updatePauseButtonIcon(); // Actualiza el botón (aunque podría ocultarse o deshabilitarse)

            // Limpia el canvas para dibujar la pantalla de victoria
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Dibuja el fondo si está disponible
            if (bgImg.complete && bgImg.naturalWidth !== 0 && bgImg.width > 0) {
                // Dibuja una versión estática del fondo (sin scroll)
                let tempGroundX = 0; // O la posición actual si quieres que coincida
                for (let i = 0; (i * bgImg.width) + (tempGroundX * 0.5) < canvas.width + bgImg.width; i++) {
                    let bgX = (i * bgImg.width) + (tempGroundX * 0.5);
                    while (bgX <= -bgImg.width && bgImg.width > 0) { bgX += bgImg.width; }
                    ctx.drawImage(bgImg, bgX , 0, bgImg.width, canvas.height - groundHeight);
                }
            } else {
                // Fallback de fondo si la imagen no cargó
                ctx.fillStyle = '#70c5ce'; // Color cielo
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
            
            // Dibuja el suelo estático
            drawGroundStatic();


            // Muestra la imagen de victoria del zorro
            if (zorroVictoriaImg.complete && zorroVictoriaImg.naturalWidth !== 0) {
                const imgWidth = zorroVictoriaImg.naturalWidth;
                const imgHeight = zorroVictoriaImg.naturalHeight;
                // Ajusta el tamaño de la imagen para que quepa bien
                let drawWidth = canvas.width * 0.9;
                let drawHeight = (imgHeight / imgWidth) * drawWidth;

                if (drawHeight > canvas.height * 0.6) {
                    drawHeight = canvas.height * 0.6;
                    drawWidth = (imgWidth / imgHeight) * drawHeight;
                }
                if (drawWidth > canvas.width * 0.9) { // Doble chequeo por si acaso
                    drawWidth = canvas.width * 0.9;
                    drawHeight = (imgHeight / imgWidth) * drawWidth;
                }

                const posX = (canvas.width - drawWidth) / 2; // Centra la imagen
                const posY = (canvas.height - drawHeight) / 4; // Posición Y

                ctx.drawImage(zorroVictoriaImg, posX, posY, drawWidth, drawHeight);
                messageDisplay.innerHTML = `¡Lo lograron!<br>"¡Vamos a conseguir la hazaña de salvar al mundo!"<br><small>Pulsa para continuar la aventura</small>`;
            } else {
                // Fallback si la imagen de victoria no carga
                messageDisplay.innerHTML = `¡FELICIDADES!<br>Alcanzaste ${scoreMetaInicial} puntos.<br><small>Pulsa para continuar</small>`;
            }
            messageDisplay.style.top = '75%'; // Más abajo para no tapar la imagen
            messageDisplay.style.display = 'block';
            scoreDisplay.textContent = score; // Mantiene el score visible
        }
        
        function drawGroundStatic() { // Función para dibujar el suelo sin scroll para pantallas de victoria/final
            if (groundImg.complete && groundImg.naturalWidth !== 0 && groundImg.width > 0) {
                 for (let i = 0; (i * groundImg.width) < canvas.width + groundImg.width; i++) { // Sin groundX
                    ctx.drawImage(groundImg, (i * groundImg.width), canvas.height - groundHeight, groundImg.width, groundHeight);
                }
            } else {
                ctx.fillStyle = '#d2b48c';
                ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight);
            }
        }


        function enterEndingSequence() {
            gameState = 'ENDING';
            pipes = []; // Limpia las tuberías
            // Coloca al zorro en una posición para la secuencia final
            motoX = canvas.width / 2 - motoSize / 2;
            motoY = canvas.height - groundHeight - motoSize - 10; // Sobre el suelo
            motoVelocity = 0; // Sin movimiento vertical

            messageDisplay.innerHTML = `¡FIN DE LA AVENTURA!`;
            messageDisplay.style.top = '30%';
            messageDisplay.style.display = 'block';
            pauseButton.style.display = 'none'; // Oculta el botón de pausa
        }

        function drawEndingSequence() {
            // Fondo oscuro para la escena final
            ctx.fillStyle = '#303030';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Suelo de "discoteca" (ejemplo)
            ctx.fillStyle = '#505050';
            for(let y = 0; y < canvas.height; y += 20) {
                for(let x = (y/20)%2 === 0 ? 0 : -10; x < canvas.width; x += 40) {
                    ctx.fillRect(x, y, 38, 18); // Pequeños rectángulos
                }
            }
            // Plataforma para el zorro
            ctx.fillStyle = '#404040';
            ctx.fillRect(0, canvas.height - groundHeight + 10, canvas.width, groundHeight - 10);

            // Dibuja al zorro bailando si la imagen (GIF) está cargada
            const dancingFoxSize = 64;
            if (dancingFoxImg.complete && dancingFoxImg.naturalWidth !== 0) {
                 ctx.drawImage(dancingFoxImg,
                    canvas.width/2 - dancingFoxSize/2, // Centrado
                    canvas.height - groundHeight - dancingFoxSize + 10, // Sobre la plataforma
                    dancingFoxSize,
                    dancingFoxSize
                );
            } else {
                // Fallback si el GIF no carga: un zorro naranja simple
                ctx.fillStyle = 'orange';
                ctx.fillRect(
                    canvas.width/2 - motoSize/2,
                    canvas.height - groundHeight - motoSize + 10,
                    motoSize,
                    motoSize);
            }

            // Decoraciones (ej. luces de discoteca)
            ctx.fillStyle = 'orange';
            ctx.fillRect(canvas.width * 0.2 - 5, canvas.height * 0.6 - 10, 10, 20); // Poste
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.2, canvas.height * 0.6 - 15, 7, 0, Math.PI * 2); // Luz
            ctx.fill();

            ctx.fillStyle = 'orange';
            ctx.fillRect(canvas.width * 0.8 - 5, canvas.height * 0.6 - 10, 10, 20); // Poste
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(canvas.width * 0.8, canvas.height * 0.6 - 15, 7, 0, Math.PI * 2); // Luz
            ctx.fill();

            scoreDisplay.textContent = '9999'; // Puntuación final
        }

        // --- Bucle Principal del Juego ---
        function gameLoop() {
            if (!isPaused || gameState === 'VICTORY_INTERMEDIATE') { // Permitir redibujar en victoria intermedia aunque esté "pausado"
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpia el canvas en cada frame

                if (gameState === 'ENDING') {
                    drawEndingSequence();
                } else if (gameState === 'VICTORY_INTERMEDIATE') {
                    // La pantalla de victoria se dibuja principalmente en mostrarPantallaVictoriaIntermedia()
                    // Aquí solo se asegura que se mantenga visible si es necesario redibujar
                    // (por ejemplo, si hubiera animaciones en esta pantalla)
                    // Re-dibujar fondo y zorro de victoria
                    if (bgImg.complete && bgImg.naturalWidth !== 0) {
                         let tempGroundX = 0; 
                         for (let i = 0; (i * bgImg.width) + (tempGroundX * 0.5) < canvas.width + bgImg.width; i++) {
                            let bgX = (i * bgImg.width) + (tempGroundX * 0.5);
                            while (bgX <= -bgImg.width && bgImg.width > 0) { bgX += bgImg.width; }
                            ctx.drawImage(bgImg, bgX , 0, bgImg.width, canvas.height - groundHeight);
                        }
                    } else {
                        ctx.fillStyle = '#70c5ce';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                    drawGroundStatic();
                    if (zorroVictoriaImg.complete && zorroVictoriaImg.naturalWidth !== 0) {
                        const imgWidth = zorroVictoriaImg.naturalWidth;
                        const imgHeight = zorroVictoriaImg.naturalHeight;
                        let drawWidth = canvas.width * 0.9;
                        let drawHeight = (imgHeight / imgWidth) * drawWidth;
                        if (drawHeight > canvas.height * 0.6) { drawHeight = canvas.height * 0.6; drawWidth = (imgWidth / imgHeight) * drawHeight; }
                        if (drawWidth > canvas.width * 0.9) { drawWidth = canvas.width * 0.9; drawHeight = (imgHeight / imgWidth) * drawWidth; }
                        const posX = (canvas.width - drawWidth) / 2;
                        const posY = (canvas.height - drawHeight) / 4;
                        ctx.drawImage(zorroVictoriaImg, posX, posY, drawWidth, drawHeight);
                    }
                } else { // Estados READY, PLAYING, PAUSED, GAMEOVER (antes de reiniciar)
                    drawBackground();
                    drawPipes();
                    drawGround();
                    drawMoto();

                    if (gameState === 'PLAYING' && !isPaused) { // Solo actualiza la lógica si está jugando y no pausado
                        updateMoto();
                        updatePipes();
                        updateGround();
                        checkCollisions(); // Comprueba colisiones después de actualizar posiciones
                        frames++; // Incrementa el contador de frames
                    }
                }
            }
            requestAnimationFrame(gameLoop); // Solicita al navegador que llame a gameLoop para el próximo frame
        }

        // --- Manejo de Entradas (Clicks, Teclas) ---
        function handleInput() {
            if (gameState === 'VICTORY_INTERMEDIATE') {
                isPaused = false; // Despausa lógicamente
                gameState = 'PLAYING'; // Continúa el juego
                messageDisplay.style.display = 'none'; // Oculta el mensaje de victoria
                updatePauseButtonIcon(); // Restaura el ícono de pausa
                // No se hace flap aquí, el juego simplemente continúa. El jugador puede hacer flap si lo desea.
                return; // Sale de la función
            }

            // Si está pausado (y no es la pantalla de victoria intermedia) o en secuencia final, no procesar saltos.
            if (isPaused && gameState !== 'ENDING') return;


            if (gameState === 'READY') {
                gameState = 'PLAYING';
                messageDisplay.style.display = 'none'; // Oculta el mensaje de "Pulsa para empezar"
                pauseButton.style.display = 'flex'; // Asegura que el botón de pausa sea visible
                flap(); // Primer salto para iniciar
            } else if (gameState === 'PLAYING') {
                flap(); // Salto normal durante el juego
            } else if (gameState === 'GAMEOVER' || gameState === 'ENDING') {
                // Reinicia el juego
                messageDisplay.style.top = '40%'; // Restaura posición del mensaje por si cambió
                init(); // Llama a la función de inicialización
                pauseButton.style.display = 'flex'; // Asegura que el botón de pausa sea visible al reiniciar
            }
        }

        function togglePause() {
            // Solo permite pausar/despausar si el juego está en PLAYING o ya PAUSED
            // Y no en estados como GAMEOVER, ENDING, VICTORY_INTERMEDIATE o READY
            if (gameState === 'PLAYING' || gameState === 'PAUSED') {
                isPaused = !isPaused;
                gameState = isPaused ? 'PAUSED' : 'PLAYING'; // Cambia el estado del juego
                messageDisplay.textContent = isPaused ? 'PAUSADO' : ''; // Muestra "PAUSADO"
                messageDisplay.style.display = isPaused ? 'block' : 'none'; // Muestra/oculta el mensaje
                updatePauseButtonIcon(); // Cambia el ícono del botón
            }
        }

        function updatePauseButtonIcon() {
            // Cambia el ícono del botón entre pausa y play
            if (isPaused && gameState !== 'VICTORY_INTERMEDIATE') { // No mostrar "Play" en pantalla de victoria
                 pauseButton.innerHTML = '<div class="playIconTriangle"></div>'; // Ícono de Play
            } else {
                 pauseButton.innerHTML = '<div class="pauseIconBar"></div><div class="pauseIconBar"></div>'; // Ícono de Pausa
            }
        }

        // --- Event Listeners (Escuchadores de Eventos) ---
        // Click o toque en el contenedor del juego (para saltar o iniciar/reiniciar)
        gameContainer.addEventListener('click', (event) => {
            // Asegura que el click no sea en el botón de pausa
            if (event.target !== pauseButton && !pauseButton.contains(event.target)) {
                handleInput();
            }
        });

        // Tecla Espacio (para saltar o iniciar/reiniciar)
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.key === ' ') { // 'Space' es más moderno, ' ' para compatibilidad
                e.preventDefault(); // Evita que la página haga scroll al presionar espacio
                handleInput();
            }
            // Podrías añadir la tecla 'P' para pausar también, si quieres
            // if (e.key === 'p' || e.key === 'P') {
            //     e.preventDefault();
            //     togglePause();
            // }
        });

        // Click en el botón de pausa
        pauseButton.addEventListener('click', (event) => {
            event.stopPropagation(); // Evita que el click se propague al gameContainer
            // No pausar/despausar en pantallas finales o de victoria
            if (gameState !== 'ENDING' && gameState !== 'VICTORY_INTERMEDIATE' && gameState !== 'GAMEOVER' && gameState !== 'READY') {
                togglePause();
            }
        });

        // --- Carga de Assets ---
        // Es crucial que todas las imágenes se carguen antes de iniciar el juego
        // para evitar errores o que se muestren elementos vacíos.
        const allAssetPaths = [
            motoFoxImg.src, pipeTopImg.src, pipeBottomImg.src,
            groundImg.src, bgImg.src, zorroVictoriaImg.src
            // No incluimos dancingFoxImg.src aquí porque es base64 y se carga sincrónicamente.
        ];
        let assetsToLoadCount = allAssetPaths.length;
        let assetsLoadedCount = 0;

        function assetLoadedCallback(imgElement, imgPath) {
            assetsLoadedCount++;
            console.log(`Asset cargado: ${imgPath} (${assetsLoadedCount}/${assetsToLoadCount})`);
            if (assetsLoadedCount === assetsToLoadCount) {
                console.log("¡Todos los assets principales cargados! Iniciando juego...");
                init(); // Inicializa las variables del juego
                gameLoop(); // Comienza el bucle del juego
            }
        }

        function assetErrorCallback(imgElement, imgPath) {
            console.error(`Error al cargar la imagen: ${imgPath}. Asegúrate que el archivo exista en la ruta especificada y el nombre sea correcto (sensible a mayúsculas/minúsculas en servidores).`);
            // Aún así contamos como "procesado" para no bloquear el inicio del juego,
            // el juego intentará usar los fallbacks (cuadros de colores).
            assetsLoadedCount++;
            if (assetsLoadedCount === assetsToLoadCount) {
                console.warn("Juego iniciado con algunos assets faltantes. Se usarán fallbacks.");
                init();
                gameLoop();
            }
        }

        // Asignar los manejadores onload y onerror a cada imagen
        // Esto es más robusto que tener contadores separados para cada imagen.
        [motoFoxImg, pipeTopImg, pipeBottomImg, groundImg, bgImg, zorroVictoriaImg].forEach(img => {
            const path = img.src; // Guardamos el src para el log, ya que img.src puede cambiar a la URL completa
            img.onload = () => assetLoadedCallback(img, path);
            img.onerror = () => assetErrorCallback(img, path);
        });
        
        // Para dancingFoxImg (base64), el `onload` es casi inmediato, pero es buena práctica tenerlo
        dancingFoxImg.onload = () => console.log("Dancing fox GIF (base64) cargado.");
        dancingFoxImg.onerror = () => console.warn('Error al cargar dancingFoxImg (base64), la secuencia final podría no mostrarla.');


        // NOTA IMPORTANTE PARA GITHUB PAGES:
        // 1. Las rutas a las imágenes ('./imagenes/...') deben ser correctas RELATIVO a tu archivo HTML.
        //    Si tu HTML está en la raíz del repositorio y las imágenes en una carpeta 'imagenes', está bien.
        // 2. GitHub Pages es SENSIBLE A MAYÚSCULAS/MINÚSCULAS en nombres de archivo y carpetas.
        //    Verifica que 'imagenes', 'motozorro.png', etc., coincidan EXACTAMENTE.
        // 3. Si sigue sin verse bien, abre la consola de desarrollador de tu navegador (usualmente F12)
        //    en la página de GitHub Pages. Busca errores en la pestaña "Consola".
        //    Los errores 404 (Not Found) para las imágenes son los más comunes.

    </script>
</body>
</html>

