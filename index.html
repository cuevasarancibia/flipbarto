<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Moto Zorro Veloz - ¡Aventura con Preguntas de Bartolo!</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #70c5ce;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Arial', sans-serif;
        }
        #gameContainer {
            position: relative;
            width: 320px;
            height: 480px;
            border: 2px solid #000;
            overflow: hidden;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            background-color: #70c5ce; /* Fondo inicial por si el canvas tarda */
        }
        canvas {
            display: block;
            background-color: transparent; /* El fondo se dibuja en el canvas o lo da el container */
        }
        .game-ui-element { /* Clase para elementos UI que se ocultan/muestran */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
            text-align: center;
            z-index: 10;
        }
        #scoreDisplay {
            top: 20px;
            font-size: 30px;
            font-weight: bold;
        }
        #messageDisplay {
            top: 40%;
            font-size: 24px;
            font-weight: bold;
            display: none;
            padding: 15px;
            background-color: rgba(0,0,0,0.4);
            border-radius: 8px;
            width: 80%;
            box-sizing: border-box;
        }
        #finalVictoryMessage { 
            top: 0; left: 0; /* No necesita transform si es 100% width/height */
            width: 100%;
            height: 100%;
            background-color: rgba(0, 85, 120, 0.9); 
            z-index: 25; 
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            box-sizing: border-box;
            font-size: 28px; 
            font-weight: bold;
        }
        #finalVictoryMessage small {
            font-size: 18px;
            margin-top: 20px;
            font-weight: normal;
        }
        #pauseButton {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 40px;
            height: 40px;
            background-color: rgba(0,0,0,0.6);
            border: 2px solid white;
            border-radius: 5px;
            cursor: pointer;
            z-index: 11;
            display: flex; /* Inicialmente oculto, se muestra al jugar */
            justify-content: center;
            align-items: center;
        }
        .pauseIconBar { width: 5px; height: 20px; background-color: white; margin: 0 2px; }
        .playIconTriangle { width: 0; height: 0; border-top: 10px solid transparent; border-bottom: 10px solid transparent; border-left: 18px solid white; }
        
        #questionModal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.85); z-index: 20; display: none;
            flex-direction: column; justify-content: center; align-items: center;
            padding: 20px; box-sizing: border-box; color: white; text-align: center;
        }
        #questionText { font-size: 17px; margin-bottom: 15px; line-height: 1.4; }
        #answerButtonsContainer button {
            display: block; width: 90%; margin: 8px auto; padding: 10px; font-size: 15px;
            background-color: #4CAF50; color: white; border: none; border-radius: 5px;
            cursor: pointer; transition: background-color 0.3s;
        }
        #answerButtonsContainer button:hover { background-color: #45a049; }

        /* Panel de Selección de Dificultad */
        #difficultySelectionModal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            z-index: 30; /* Encima de todo al inicio */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }
        #difficultySelectionModal h2 { margin-top: 0; margin-bottom: 20px; font-size: 22px; }
        #difficultySelectionModal label { display: block; margin: 15px 0 5px 0; font-size: 16px;}
        #difficultySlider { width: 80%; margin-bottom: 5px; }
        #difficultyValue { font-weight: bold; font-size: 18px; margin-bottom: 20px; }
        #difficultySelectionModal .checkbox-container { margin: 20px 0; font-size: 16px; }
        #difficultySelectionModal .checkbox-container input { margin-right: 8px; vertical-align: middle;}
        #startGameButton {
            padding: 12px 25px; font-size: 18px; background-color: #28a745; color: white;
            border: none; border-radius: 5px; cursor: pointer; transition: background-color 0.3s;
            margin-top: 20px;
        }
        #startGameButton:hover { background-color: #218838; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="difficultySelectionModal">
            <h2>Selecciona la Dificultad</h2>
            <label for="difficultySlider">Nivel de Dificultad: <span id="difficultyValue">5</span></label>
            <input type="range" id="difficultySlider" min="1" max="10" value="5">
            
            <div class="checkbox-container">
                <input type="checkbox" id="progressiveDifficultyCheckbox">
                <label for="progressiveDifficultyCheckbox">Dificultad en Crecimiento (cada 3 puntos)</label>
            </div>

            <button id="startGameButton">Iniciar Juego</button>
        </div>

        <canvas id="gameCanvas"></canvas>
        <div id="scoreDisplay" class="game-ui-element" style="display: none;">0</div>
        <div id="messageDisplay" class="game-ui-element"></div> <div id="finalVictoryMessage" class="game-ui-element"> ¡Eres lo mejor que hay, muchas gracias!!<br>¡GANASTE!
            <br><small>Pulsa para jugar de nuevo</small>
        </div>
        <div id="pauseButton" style="display: none;"></div> <div id="questionModal">
            <div id="questionText"></div>
            <div id="answerButtonsContainer"></div>
        </div>
    </div>

    <script>
        // --- Elementos del DOM ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const messageDisplay = document.getElementById('messageDisplay');
        const finalVictoryMessageDisplay = document.getElementById('finalVictoryMessage');
        const pauseButton = document.getElementById('pauseButton');
        const questionModal = document.getElementById('questionModal');
        const questionText = document.getElementById('questionText');
        const answerButtonsContainer = document.getElementById('answerButtonsContainer');

        // Elementos del Panel de Dificultad
        const difficultySelectionModal = document.getElementById('difficultySelectionModal');
        const difficultySlider = document.getElementById('difficultySlider');
        const difficultyValueDisplay = document.getElementById('difficultyValue');
        const progressiveDifficultyCheckbox = document.getElementById('progressiveDifficultyCheckbox');
        const startGameButton = document.getElementById('startGameButton');

        canvas.width = 320; canvas.height = 480;

        // --- ASSETS ---
        const motoFoxImg = new Image();
        const pipeTopImg = new Image();
        const pipeBottomImg = new Image();
        const groundImg = new Image();
        const bgImg = new Image();
        const dancingFoxImg = new Image(); 

        motoFoxImg.src = './imagenes/motozorro.png';
        pipeTopImg.src = './imagenes/tuberia_arriba.svg';
        pipeBottomImg.src = './imagenes/tuberia_abajo.svg';
        groundImg.src = './imagenes/suelo.svg';
        bgImg.src = './imagenes/fondo_juego.svg';
        dancingFoxImg.src = 'data:image/gif;base64,R0lGODlhIAAgAPIEAAAAAP/OAAAA/84A////AAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJFAACACwAAAAAIAAgAAADXei63P4wykmrvTjrzbv/YCiOZGmeaKqubOu+cCzPdG3feK7vfO//wKBwSCwaj8ikcslsOp/QqHRKrVqv2Kx2y+16v+CweEwum8/otHrNbrvf8Lh8Tq/b7/i8fs/v+/+AgYKDhIWGh4iJiouMjY6PkJGSk5SVlpeYmZqbnJ2en6ChooqMhR0AAAAh+QQJFAACACwEAAIAFwAWAAADQHi63P4wykmrvTjrzbv/YCiOZGmeaKqubOu+cCzPdG3feK7vfO//wKAwSBQeiEghlHMpyfE0pFQrjVLjB+xOq3f0mJxbM9oVAAA7';


        // --- Variables del Juego ---
        let motoX, motoY, motoVelocity, motoSize;
        let gravity, currentGravity; 
        let pipes;
        let pipeWidth, pipeGap, currentPipeGap;
        let pipeOriginalSpeed, currentPipeSpeed;
        let score;
        let gameState = 'DIFFICULTY_SELECTION'; 
        let isPaused = false;
        let groundHeight = 50;
        let groundX = 0;

        // --- Variables para Delta Time ---
        let lastTime = 0;
        const TARGET_FPS = 60;

        // --- Variables para el Sistema de Preguntas ---
        let isAnsweringQuestion = false;
        let currentQuestionData = null;
        const questions = [ 
            { text: "¿Cuál es el nombre del niño que tiene una cama voladora?", options: ["a) Bernardo", "b) Bartolo", "c) Benjamín"], correctAnswerIndex: 1 },
            { text: "En la ciudad secreta de los Andes, ¿cuál es el principal problema que deben resolver Bartolo y sus nuevos amigos?", options: ["a) Una inundación que amenaza la ciudad.", "b) Un meteorito que ha tapado el cráter por donde sale el sol.", "c) La desaparición del libro de hechizos de la ciudad."], correctAnswerIndex: 1 },
            { text: "¿Cuál de estos animales NO es un personaje que Bartolo conoce en la ciudad secreta?", options: ["a) Pascual, el conejo.", "b) Valentín, el puma.", "c) Lorenzo, el loro."], correctAnswerIndex: 2 },
            { text: "¿Qué personaje ayuda a Bartolo y los animales a llegar al fondo del lago para buscar una solución al problema del meteorito?", options: ["a) Un cóndor gigante.", "b) Sofía, la niña, con un submarino especial.", "c) Un antiguo mapa encontrado en la biblioteca de la ciudad."], correctAnswerIndex: 1 },
            { text: "¿Qué utilizan finalmente para mover el meteorito que tapa el sol?", options: ["a) La fuerza combinada de todos los animales de la ciudad.", "b) Una erupción volcánica controlada.", "c) La propia cama mágica de Bartolo, usada de una forma ingeniosa."], correctAnswerIndex: 2 },
            { text: "¿Qué característica especial tiene la ciudad secreta en la cordillera, además de ser habitada por animales que hablan?", options: ["a) Los edificios están hechos de nubes.", "b) Dependen de un sol que sale por un cráter específico.", "c) Cambia de ubicación cada noche para no ser descubierta."], correctAnswerIndex: 1 },
            { text: "¿Cuál es uno de los mensajes o temas principales que se pueden extraer del libro \"La cama mágica de Bartolo\"?", options: ["a) La importancia de la tecnología sobre la naturaleza.", "b) La desconfianza hacia los extraños.", "c) El valor de la amistad, la colaboración y la creatividad para resolver problemas."], correctAnswerIndex: 2 },
            { text: "Al final de la aventura en la cordillera, ¿cómo regresa Bartolo a su hogar?", options: ["a) Los animales construyen una catapulta gigante.", "b) Su cama lo lleva de vuelta, aunque de una manera un tanto accidentada y veloz.", "c) Sofía lo acompaña en un avión especial."], correctAnswerIndex: 1 },
            { text: "¿Quién es Sofía en la historia?", options: ["a) La hermana de Bartolo que lo espera en casa.", "b) Una estrella que guía a Bartolo en su viaje.", "c) Una niña aventurera que vive en la ciudad secreta y ayuda a resolver el problema del sol."], correctAnswerIndex: 2 },
            { text: "¿Qué actitud o cualidad de Bartolo es fundamental para enfrentar los desafíos en la ciudad secreta?", options: ["a) Su escepticismo y cautela ante lo desconocido.", "b) Su ingenio y disposición a escuchar y valorar las ideas de los demás.", "c) Su fuerza física superior a la de los animales."], correctAnswerIndex: 1 }
        ];
        let totalQuestionsInGame = questions.length; 
        let questionsAnsweredCorrectlyThisSession = 0; 
        let availableQuestions = [];
        const questionMilestones = [3, 6, 11, 17, 20];
        let milestonesReached = [];
        let lastScoreThatTriggeredQuestion = 0;
        
        // --- Variables de Dificultad ---
        let currentDifficultyLevel = 5; 
        let progressiveDifficultyEnabled = false;
        let lastDifficultyIncreaseScore = 0;
        let pipeSpawnTimer = 0;
        let PIPE_SPAWN_INTERVAL, currentPipeSpawnInterval; 

        const difficultyParams = {
            gravity:           { min: 0.04, max: 0.20 }, 
            pipeSpeed:         { min: 0.7,  max: 3.5  }, 
            pipeSpawnInterval: { min: 4.0,  max: 1.0  }, 
            pipeGap:           { min: 250,  max: 110  }  
        };

        function applyDifficultySettings(level) {
            const factor = (level - 1) / 9; 

            gravity = difficultyParams.gravity.min + (difficultyParams.gravity.max - difficultyParams.gravity.min) * factor;
            pipeOriginalSpeed = difficultyParams.pipeSpeed.min + (difficultyParams.pipeSpeed.max - difficultyParams.pipeSpeed.min) * factor;
            PIPE_SPAWN_INTERVAL = difficultyParams.pipeSpawnInterval.max - (difficultyParams.pipeSpawnInterval.max - difficultyParams.pipeSpawnInterval.min) * factor; 
            pipeGap = difficultyParams.pipeGap.max - (difficultyParams.pipeGap.max - difficultyParams.pipeGap.min) * factor; 

            currentGravity = gravity;
            currentPipeSpeed = pipeOriginalSpeed;
            currentPipeSpawnInterval = PIPE_SPAWN_INTERVAL;
            currentPipeGap = pipeGap;

            console.log(`Dificultad Nivel ${level}: G=${gravity.toFixed(3)}, Speed=${pipeOriginalSpeed.toFixed(2)}, Spawn=${PIPE_SPAWN_INTERVAL.toFixed(2)}s, Gap=${pipeGap.toFixed(0)}px`);
        }

        function increaseDifficultyStep() {
            currentGravity += 0.003; 
            currentPipeSpeed += 0.08;   
            if (currentPipeSpawnInterval > 0.8) currentPipeSpawnInterval -= 0.04; 
            if (currentPipeGap > 100) currentPipeGap -= 2; 
            
            console.log(`Dificultad Progresiva: G=${currentGravity.toFixed(3)}, Speed=${currentPipeSpeed.toFixed(2)}, Spawn=${currentPipeSpawnInterval.toFixed(2)}s, Gap=${currentPipeGap.toFixed(0)}px`);
        }

        function initGameLogic() { 
            motoSize = 40; motoX = 60; motoY = canvas.height / 2 - motoSize / 2;
            motoVelocity = 0; 
            pipes = []; pipeWidth = 64; 
            score = 0; 
            
            isPaused = false; 
            isAnsweringQuestion = false; questionModal.style.display = 'none';
            finalVictoryMessageDisplay.style.display = 'none'; 
            messageDisplay.style.display = 'none'; 
            scoreDisplay.style.display = 'block'; 
            pauseButton.style.display = 'flex';   
            
            availableQuestions = [...questions]; 
            questionsAnsweredCorrectlyThisSession = 0; 
            milestonesReached = [];
            lastScoreThatTriggeredQuestion = 0;
            lastDifficultyIncreaseScore = 0; 
            pipeSpawnTimer = currentPipeSpawnInterval; 

            lastTime = 0; 

            updatePauseButtonIcon();
            scoreDisplay.textContent = score;
        }

        difficultySlider.addEventListener('input', (e) => {
            currentDifficultyLevel = parseInt(e.target.value);
            difficultyValueDisplay.textContent = currentDifficultyLevel;
        });

        startGameButton.addEventListener('click', () => {
            applyDifficultySettings(currentDifficultyLevel);
            progressiveDifficultyEnabled = progressiveDifficultyCheckbox.checked;
            
            difficultySelectionModal.style.display = 'none'; 
            gameState = 'READY'; 
            messageDisplay.innerHTML = 'Pulsa o haz clic<br>para Empezar la Aventura';
            messageDisplay.style.display = 'block';
        });

        function drawMoto() { 
            ctx.save();
            ctx.translate(motoX + motoSize / 2, motoY + motoSize / 2);
            let angle = Math.min(Math.PI / 8, motoVelocity * 0.08); ctx.rotate(angle);
            if (motoFoxImg.complete && motoFoxImg.naturalWidth > 0) {
                ctx.drawImage(motoFoxImg, -motoSize / 2, -motoSize / 2, motoSize, motoSize);
            }
            ctx.restore();
        }
        function drawPipes() { 
            pipes.forEach(pipe => {
                if (pipeTopImg.complete && pipeTopImg.naturalWidth > 0) {
                    ctx.drawImage(pipeTopImg, pipe.x, 0, pipeWidth, pipe.topHeight);
                }
                if (pipeBottomImg.complete && pipeBottomImg.naturalWidth > 0) {
                    ctx.drawImage(pipeBottomImg, pipe.x, pipe.topHeight + currentPipeGap, pipeWidth, canvas.height - pipe.topHeight - currentPipeGap - groundHeight);
                }
            });
        }
        function drawGround() { 
            if (groundImg.complete && groundImg.naturalWidth > 0 && groundImg.width > 0) {
                 for (let i = 0; (i * groundImg.width) + groundX < canvas.width + groundImg.width; i++) {
                    ctx.drawImage(groundImg, (i * groundImg.width) + groundX, canvas.height - groundHeight, groundImg.width, groundHeight);
                }
            }
        }
        function drawBackground() { 
            if (bgImg.complete && bgImg.naturalWidth > 0 && bgImg.width > 0) { 
                 for (let i = 0; (i * bgImg.width) + (groundX * 0.5) < canvas.width + bgImg.width; i++) {
                    let bgX = (i * bgImg.width) + (groundX * 0.5);
                    while (bgX <= -bgImg.width && bgImg.width > 0) { bgX += bgImg.width; }
                    ctx.drawImage(bgImg, bgX , 0, bgImg.width, canvas.height - groundHeight);
                }
            }
        }
        
        function updateMoto(deltaTime) { 
            motoVelocity += currentGravity * TARGET_FPS * deltaTime;
            motoY += motoVelocity * TARGET_FPS * deltaTime;
            if (motoY < -motoSize * 0.2) { 
                motoY = -motoSize * 0.2; 
                motoVelocity = currentGravity * 2 * TARGET_FPS * deltaTime; 
            }
        }

        function updatePipes(deltaTime) { 
            pipeSpawnTimer += deltaTime;
            if (pipeSpawnTimer >= currentPipeSpawnInterval) {
                pipeSpawnTimer = 0; 
                let minTopHeight = 80;
                let maxTopHeightPossible = canvas.height - groundHeight - currentPipeGap - 80;
                if (maxTopHeightPossible < minTopHeight) maxTopHeightPossible = minTopHeight + 10; 
                let topHeight = Math.random() * (maxTopHeightPossible - minTopHeight) + minTopHeight;
                pipes.push({ x: canvas.width, topHeight: topHeight, passed: false });
            }

            pipes.forEach(pipe => {
                pipe.x -= currentPipeSpeed * TARGET_FPS * deltaTime; 
                if (pipe.x + pipeWidth < 0) { pipes.shift(); }

                if (!pipe.passed && pipe.x + pipeWidth < motoX) {
                    pipe.passed = true;
                    score++;
                    scoreDisplay.textContent = score;

                    if (progressiveDifficultyEnabled && score > 0 && score % 3 === 0 && score !== lastDifficultyIncreaseScore) {
                        increaseDifficultyStep();
                        lastDifficultyIncreaseScore = score;
                    }

                    let questionShouldBeTriggered = false;
                    for (let i = 0; i < questionMilestones.length; i++) {
                        const milestone = questionMilestones[i];
                        if (score === milestone && !milestonesReached.includes(milestone)) {
                            questionShouldBeTriggered = true;
                            milestonesReached.push(milestone);
                            break; 
                        }
                    }
                    if (!questionShouldBeTriggered && score > 20 && score % 5 === 0) {
                        if (!milestonesReached.includes(score) && score !== lastScoreThatTriggeredQuestion) {
                            questionShouldBeTriggered = true;
                        }
                    }
                    if (questionShouldBeTriggered) {
                        if (!isAnsweringQuestion && gameState === 'PLAYING') {
                            triggerQuestion();
                            lastScoreThatTriggeredQuestion = score;
                        }
                    }
                    
                    if (!isAnsweringQuestion && gameState !== 'FINAL_VICTORY') { 
                         if (score === 9999 && gameState !== 'ENDING') { 
                            enterEndingSequence();
                        }
                    }
                }
            });
        }

        function checkCollisions() {   
            if (gameState !== 'PLAYING' || isAnsweringQuestion) return;
            if (motoY + motoSize > canvas.height - groundHeight) {
                motoY = canvas.height - groundHeight - motoSize;
                gameOver("¡Caíste al suelo!"); return;
            }
            for (let pipe of pipes) {
                const m = 2; 
                if (motoX + motoSize - m > pipe.x && motoX + m < pipe.x + pipeWidth &&
                    motoY + motoSize - m > pipe.topHeight + currentPipeGap) { 
                    gameOver("¡Chocaste con una tubería!"); return;
                }
                if (motoX + motoSize - m > pipe.x && motoX + m < pipe.x + pipeWidth &&
                    motoY + m < pipe.topHeight) {
                    gameOver("¡Chocaste con una tubería!"); return;
                }
            }
        }

        function updateGround(deltaTime) { 
            groundX -= currentPipeSpeed * TARGET_FPS * deltaTime; 
            if (groundImg.complete && groundImg.naturalWidth > 0 && groundImg.width > 0) {
                if (groundX <= -groundImg.width) { groundX += groundImg.width; }
            }
        }

        function flap() { 
            if (gameState === 'PLAYING' && !isPaused && !isAnsweringQuestion) {
                motoVelocity = -2.8; 
            }
        }
        function gameOver(reason = "¡Oh no, Zorro!") { 
            if (gameState === 'GAMEOVER' || gameState === 'ENDING' || gameState === 'FINAL_VICTORY') return;
            gameState = 'GAMEOVER'; 
            isPaused = true; 
            messageDisplay.innerHTML = `${reason}<br>Puntuación Final: ${score}<br><small>Pulsa para reintentar</small>`;
            messageDisplay.style.top = '40%'; messageDisplay.style.display = 'block';
            questionModal.style.display = 'none';
            finalVictoryMessageDisplay.style.display = 'none'; 
        }
        function drawGroundStatic() { 
            if (groundImg.complete && groundImg.naturalWidth > 0 && groundImg.width > 0) {
                 for (let i = 0; (i * groundImg.width) < canvas.width + groundImg.width; i++) {
                    ctx.drawImage(groundImg, (i * groundImg.width), canvas.height - groundHeight, groundImg.width, groundHeight);
                }
            } else { ctx.fillStyle = '#d2b48c'; ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight); }
        }
        function drawBackgroundStatic() {   
            if (bgImg.complete && bgImg.naturalWidth > 0 && bgImg.width > 0) {
                 for (let i = 0; (i * bgImg.width) < canvas.width + bgImg.width; i++) {
                    ctx.drawImage(bgImg, (i * bgImg.width) , 0, bgImg.width, canvas.height - groundHeight);
                }
            } else { 
                ctx.fillStyle = '#70c5ce'; 
                ctx.fillRect(0,0, canvas.width, canvas.height - groundHeight);
            }
        }
        function enterEndingSequence() {   
            if (gameState === 'FINAL_VICTORY') return; 
            gameState = 'ENDING'; pipes = [];
            motoX = canvas.width / 2 - motoSize / 2; motoY = canvas.height - groundHeight - motoSize - 10;
            motoVelocity = 0; messageDisplay.innerHTML = `¡FIN DE LA AVENTURA!`;
            messageDisplay.style.top = '30%'; messageDisplay.style.display = 'block';
            pauseButton.style.display = 'none';
        }
        function drawEndingSequence() { 
            ctx.fillStyle = '#303030'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#505050';
            for(let y=0; y<canvas.height; y+=20) for(let x=(y/20)%2===0?0:-10; x<canvas.width; x+=40) ctx.fillRect(x,y,38,18);
            ctx.fillStyle = '#404040'; ctx.fillRect(0, canvas.height - groundHeight + 10, canvas.width, groundHeight-10);
            const dFS = 64;
            if (dancingFoxImg.complete && dancingFoxImg.naturalWidth > 0) {
                 ctx.drawImage(dancingFoxImg, canvas.width/2 - dFS/2, canvas.height - groundHeight - dFS + 10, dFS, dFS);
            } else { ctx.fillStyle = 'orange'; ctx.fillRect(canvas.width/2 - motoSize/2, canvas.height - groundHeight - motoSize + 10, motoSize, motoSize); }
            ctx.fillStyle='orange'; ctx.fillRect(canvas.width*0.2-5,canvas.height*0.6-10,10,20); ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(canvas.width*0.2,canvas.height*0.6-15,7,0,Math.PI*2); ctx.fill();
            ctx.fillStyle='orange'; ctx.fillRect(canvas.width*0.8-5,canvas.height*0.6-10,10,20); ctx.fillStyle='red'; ctx.beginPath(); ctx.arc(canvas.width*0.8,canvas.height*0.6-15,7,0,Math.PI*2); ctx.fill();
            scoreDisplay.textContent = '9999';
        }
        function showFinalVictory() { 
            gameState = 'FINAL_VICTORY';
            isPaused = true;
            questionModal.style.display = 'none';
            messageDisplay.style.display = 'none';
            finalVictoryMessageDisplay.style.display = 'flex';
            pauseButton.style.display = 'none'; 
        }
        function triggerQuestion() { 
            if (availableQuestions.length === 0) { 
                console.log("Se intentó disparar pregunta, pero ya no hay disponibles.");
                if (gameState !== 'FINAL_VICTORY') { 
                     showFinalVictory();
                }
                return; 
            }
            if (isAnsweringQuestion || gameState !== 'PLAYING') return;

            isAnsweringQuestion = true; isPaused = true;
            updatePauseButtonIcon();

            const questionIndex = Math.floor(Math.random() * availableQuestions.length);
            currentQuestionData = availableQuestions.splice(questionIndex, 1)[0]; 

            questionText.textContent = currentQuestionData.text;
            answerButtonsContainer.innerHTML = ''; 

            currentQuestionData.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.textContent = option;
                button.onclick = () => selectAnswer(index);
                answerButtonsContainer.appendChild(button);
            });
            questionModal.style.display = 'flex';
        }
        function selectAnswer(selectedIndex) { 
            if (!currentQuestionData) return;

            if (selectedIndex === currentQuestionData.correctAnswerIndex) {
                questionsAnsweredCorrectlyThisSession++; 
                
                if (availableQuestions.length === 0 && questionsAnsweredCorrectlyThisSession === totalQuestionsInGame) {
                    questionModal.style.display = 'none'; 
                    showFinalVictory();
                } else {
                    messageDisplay.innerHTML = "¡Correcto!<br>Continúa la aventura.";
                    messageDisplay.style.display = 'block';
                    setTimeout(() => {
                        messageDisplay.style.display = 'none';
                        isAnsweringQuestion = false; isPaused = false;
                        updatePauseButtonIcon(); questionModal.style.display = 'none';
                    }, 1500);
                }
            } else {
                questionModal.style.display = 'none'; 
                gameOver("¡Respuesta incorrecta!"); 
            }
            currentQuestionData = null;
        }
        
        function gameLoop(timestamp) {
            if (gameState === 'DIFFICULTY_SELECTION') { 
                requestAnimationFrame(gameLoop);
                return;
            }

            if (lastTime === 0 && gameState !== 'READY') { 
                 lastTime = timestamp;
            } else if (gameState === 'READY') { 
                lastTime = 0; 
            }

            let deltaTime = 0;
            if (lastTime !== 0) { 
                deltaTime = (timestamp - lastTime) / 1000;
            }
            lastTime = timestamp;
            deltaTime = Math.min(deltaTime, 0.1); 

            if (gameState === 'FINAL_VICTORY') {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                drawBackgroundStatic(); 
                drawGroundStatic();     
                requestAnimationFrame(gameLoop);
                return; 
            }

            if (!isPaused && gameState !== 'READY') { 
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (gameState === 'ENDING') { drawEndingSequence(); }
                else { 
                    drawBackground(); drawPipes(); drawGround(); drawMoto();
                    if (gameState === 'PLAYING' && !isAnsweringQuestion) { 
                        updateMoto(deltaTime); 
                        updatePipes(deltaTime); 
                        updateGround(deltaTime); 
                        checkCollisions(); 
                    }
                }
            } else if (gameState === 'READY' && !isPaused) { 
                 ctx.clearRect(0, 0, canvas.width, canvas.height);
                 drawBackgroundStatic(); 
                 drawGroundStatic();
            }
            requestAnimationFrame(gameLoop); 
        }

        function handleInput() {
            if (isAnsweringQuestion && gameState !== 'GAMEOVER') return;
            
            if (gameState === 'FINAL_VICTORY') { 
                difficultySelectionModal.style.display = 'flex'; 
                finalVictoryMessageDisplay.style.display = 'none';
                scoreDisplay.style.display = 'none';
                pauseButton.style.display = 'none';
                gameState = 'DIFFICULTY_SELECTION'; 
                return;
            }
            
            if (isPaused && gameState !== 'GAMEOVER' && gameState !== 'READY') return;

            if (gameState === 'READY') {
                initGameLogic(); 
                gameState = 'PLAYING'; 
                isPaused = false; 
                messageDisplay.style.display = 'none'; 
                lastTime = 0; 
                flap();
            } else if (gameState === 'PLAYING' && !isPaused) { 
                 flap(); 
            } else if (gameState === 'GAMEOVER' || gameState === 'ENDING') { 
                difficultySelectionModal.style.display = 'flex'; 
                messageDisplay.style.display = 'none'; 
                scoreDisplay.style.display = 'none';
                pauseButton.style.display = 'none';
                gameState = 'DIFFICULTY_SELECTION'; 
            }
        }
        
        function togglePause() {
            if (isAnsweringQuestion || gameState === 'ENDING' || gameState === 'GAMEOVER' || gameState === 'READY' || gameState === 'FINAL_VICTORY' || gameState === 'DIFFICULTY_SELECTION') return;
            if (gameState === 'PLAYING' || gameState === 'PAUSED') {
                isPaused = !isPaused; 
                if (!isPaused) { 
                    lastTime = performance.now(); 
                }
                gameState = isPaused ? 'PAUSED' : 'PLAYING';
                messageDisplay.textContent = isPaused ? 'PAUSADO' : '';
                messageDisplay.style.display = isPaused ? 'block' : 'none';
                updatePauseButtonIcon();
            }
        }

        function updatePauseButtonIcon() {
            if (isPaused && !isAnsweringQuestion && gameState !== 'FINAL_VICTORY') { 
                 pauseButton.innerHTML = '<div class="playIconTriangle"></div>';
            } else {
                 pauseButton.innerHTML = '<div class="pauseIconBar"></div><div class="pauseIconBar"></div>';
            }
        }

        gameContainer.addEventListener('click', (event) => {
            if (difficultySelectionModal.style.display === 'flex' && difficultySelectionModal.contains(event.target)) return;
            if (questionModal.style.display === 'flex' && questionModal.contains(event.target)) return;
            if (finalVictoryMessageDisplay.style.display === 'flex' && finalVictoryMessageDisplay.contains(event.target)) {
                 handleInput(); 
                 return;
            }
            if (event.target === pauseButton || (pauseButton && pauseButton.contains(event.target))) return;
            handleInput();
        });

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' || e.key === ' ') { 
                e.preventDefault(); 
                if (difficultySelectionModal.style.display === 'flex') return; 
                handleInput(); 
            }
        });
        pauseButton.addEventListener('click', (event) => { event.stopPropagation(); togglePause(); });

        // --- Carga de Assets e Inicio ---
        const assetList = [
            {img: motoFoxImg, src: './imagenes/motozorro.png', placeholder: 'https://placehold.co/40x40/FFA500/FFFFFF?text=Zorro', name: 'motoFoxImg'},
            {img: pipeTopImg, src: './imagenes/tuberia_arriba.svg', placeholder: 'https://placehold.co/64x200/008000/FFFFFF?text=Tubo', name: 'pipeTopImg'},
            {img: pipeBottomImg, src: './imagenes/tuberia_abajo.svg', placeholder: 'https://placehold.co/64x200/008000/FFFFFF?text=Tubo', name: 'pipeBottomImg'},
            {img: groundImg, src: './imagenes/suelo.svg', placeholder: `https://placehold.co/${canvas.width}x${groundHeight}/D2B48C/000000?text=Suelo`, name: 'groundImg'},
            {img: bgImg, src: './imagenes/fondo_juego.svg', placeholder: `https://placehold.co/${canvas.width}x${canvas.height - groundHeight}/70C5CE/FFFFFF?text=Fondo`, name: 'bgImg'}
        ];
        let assetsToLoadCount = assetList.length; 
        let assetsLoadedCount = 0;

        function assetLoadedCallback(assetName, isPlaceholder) {
            assetsLoadedCount++; 
            if (isPlaceholder) {
                console.log(`Placeholder para ${assetName} cargado (${assetsLoadedCount}/${assetsToLoadCount})`);
            } else {
                console.log(`Asset ${assetName} (${assetEntry.src}) cargado (${assetsLoadedCount}/${assetsToLoadCount})`);
            }
            
            if (assetsLoadedCount === assetsToLoadCount) { 
                console.log("¡Todos los assets principales (o sus fallbacks) listos!"); 
                requestAnimationFrame(gameLoop);
            }
        }

        function assetErrorFallback(assetEntry) {
            // Mensaje de error más explícito para el usuario
            console.error(`FALLO AL CARGAR: "${assetEntry.src}" - VERIFICA LA RUTA Y EL NOMBRE DEL ARCHIVO. Usando placeholder temporal: "${assetEntry.placeholder}"`);
            assetEntry.img.onerror = null; // Prevenir bucles de error si el placeholder también falla
            assetEntry.img.src = assetEntry.placeholder;
            // Cuando el placeholder se cargue, llamar a assetLoadedCallback
            assetEntry.img.onload = () => assetLoadedCallback(assetEntry.name, true); 
        }

        assetList.forEach(assetEntry => { 
            assetEntry.img.onload = () => assetLoadedCallback(assetEntry.name, false);
            assetEntry.img.onerror = () => assetErrorFallback(assetEntry);
            // El src ya está asignado arriba, así que la carga comienza inmediatamente.
        });

        dancingFoxImg.onload = () => console.log("Dancing fox GIF (base64) cargado.");
        dancingFoxImg.onerror = () => console.warn('Error al cargar dancingFoxImg (base64).');

    </script>
</body>
</html>
